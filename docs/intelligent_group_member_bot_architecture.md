# ü§ñ Êô∫ÊÖßÁæ§ÁµÑÊàêÂì°Ê©üÂô®‰∫∫Âº∑ÂåñÊû∂ÊßãË®≠Ë®à

## üìã Ë®≠Ë®àÁêÜÂøµ

**Ê†∏ÂøÉÊ¶ÇÂøµÔºöÊ©üÂô®‰∫∫‰ΩúÁÇ∫Áæ§ÁµÑ‰∏≠ÁöÑÊô∫ÊÖßÊàêÂì°ÔºåËÉΩÂ§†ÁêÜËß£Â§ö‰∫∫Â∞çË©±ËÑàÁµ°Ôºå‰∏ªÂãïÊï¥ÂêàÂ§öÁ®ÆË≥áË®ä‰æÜÊ∫êÔºåÊèê‰æõÊúâÊÑèÁæ©ÁöÑ‰∫íÂãï**

### Ë®≠Ë®àÂéüÂâá
- üß† **ÊÉÖÂ¢ÉÊÑüÁü•**ÔºöÁêÜËß£Â§ö‰∫∫Â∞çË©±ÁöÑÂãïÊÖãÂíåÈóú‰øÇ
- üîÑ **Ë≥áË®äÊï¥Âêà**ÔºöÊô∫ÊÖßÈÅ∏ÊìáÂíåËûçÂêà‰∏çÂêåÈ°ûÂûãÁöÑË≥áË®ä
- üë• **Áæ§ÁµÑÂ∞éÂêë**Ôºö‰ª•ÂèÉËàáÁæ§ÁµÑ‰∫íÂãïÁÇ∫Ê†∏ÂøÉÔºåËÄåÈùûË¢´ÂãïÂõûÊáâ
- üöÄ **‰∏ªÂãïÊô∫ÊÖß**ÔºöÊ†πÊìöÊÉÖÊ≥Å‰∏ªÂãïÊèê‰æõÁõ∏ÈóúË≥áË®äÂíåÂª∫Ë≠∞

## üèóÔ∏è Êï¥È´îÊû∂ÊßãË®≠Ë®à

```mermaid
graph TB
    subgraph "Ë®äÊÅØËôïÁêÜÂ±§"
        A[Discord Message] --> B[Multi-Person Conversation Analyzer]
        B --> C[Context Intelligence Engine]
        C --> D[Information Source Selector]
    end
    
    subgraph "Ë≥áË®ä‰æÜÊ∫êÂ±§"
        D --> E[Current Conversation Record]
        D --> F[User Information System]
        D --> G[Tool Response Cache]
        D --> H[Long-term Memory System]
    end
    
    subgraph "Êô∫ÊÖßÊ±∫Á≠ñÂ±§"
        I[Conversation Flow Analyzer] --> J[Multi-participant Intent Engine]
        J --> K[Dynamic Context Builder]
        K --> L[Response Strategy Selector]
    end
    
    subgraph "Â¢ûÂº∑Áâà ActionHandler"
        M[Enhanced ActionHandler] --> N[Tool Registry & Orchestrator]
        N --> O[Information Integration Engine]
        O --> P[Group-Aware Response Generator]
    end
    
    subgraph "Áµ±‰∏Ä SQLite Ë≥áÊñôÂ≠òÂÑ≤Â±§"
        Q[(Main SQLite Database)]
        R[(FAISS Vector Index)]
        
        Q --> S[Conversations Table]
        Q --> T[Users Table]
        Q --> U[User_Profiles Table]
        Q --> V[Schedules Table]
        Q --> W[Reminders Table]
        Q --> X[Tool_Responses Table]
        Q --> Y[Memory_Index Table]
        Q --> Z[User_Nicknames Table]
    end
    
    E --> Q
    F --> Q
    G --> Q
    H --> Q
    H --> R
    
    C --> I
    L --> M
    P --> AA[Discord Response]
```

## üóÑÔ∏è Áµ±‰∏Ä SQLite Ë≥áÊñôÂ∫´Ë®≠Ë®à

### Ë≥áÊñôÂ∫´Êû∂ÊßãÂúñ

```mermaid
erDiagram
    CONVERSATIONS {
        string conversation_id PK
        string channel_id
        string guild_id
        datetime timestamp
        text content
        string user_id
        string message_type
        text metadata
        float relevance_score
    }
    
    USERS {
        string user_id PK
        string discord_id
        string primary_nickname
        datetime created_at
        datetime last_active
        text preferences
        text activity_patterns
    }
    
    USER_PROFILES {
        string profile_id PK
        string user_id FK
        text profile_data
        text interaction_history
        text schedule_preferences
        datetime updated_at
    }
    
    USER_NICKNAMES {
        string nickname_id PK
        string user_id FK
        string nickname
        float confidence_score
        datetime first_used
        datetime last_used
        boolean is_primary
    }
    
    SCHEDULES {
        string schedule_id PK
        string user_id FK
        string title
        datetime start_time
        datetime end_time
        text description
        text schedule_data
        boolean is_recurring
        text recurrence_pattern
    }
    
    REMINDERS {
        string reminder_id PK
        string user_id FK
        string channel_id
        text message
        datetime remind_time
        datetime created_at
        string status
        text metadata
    }
    
    TOOL_RESPONSES {
        string response_id PK
        string tool_name
        text input_parameters
        text output_data
        float execution_time
        datetime timestamp
        string conversation_id FK
        float relevance_score
    }
    
    MEMORY_INDEX {
        string memory_id PK
        string conversation_id FK
        string channel_id
        text content
        text entities
        text summary
        datetime timestamp
        float importance_score
    }
    
    KNOWLEDGE_GRAPH {
        string entity_id PK
        string entity_name
        string entity_type
        text properties
        datetime created_at
        datetime updated_at
    }
    
    ENTITY_RELATIONSHIPS {
        string relationship_id PK
        string entity1_id FK
        string entity2_id FK
        string relationship_type
        float confidence_score
        datetime created_at
    }
    
    USERS ||--o{ USER_PROFILES : has
    USERS ||--o{ USER_NICKNAMES : has
    USERS ||--o{ SCHEDULES : owns
    USERS ||--o{ REMINDERS : creates
    CONVERSATIONS ||--o{ TOOL_RESPONSES : generates
    CONVERSATIONS ||--|| MEMORY_INDEX : indexed_by
    KNOWLEDGE_GRAPH ||--o{ ENTITY_RELATIONSHIPS : participates_in
```

### SQLite Ë≥áÊñôË°®Ë®≠Ë®à

```sql
-- Â∞çË©±Ë®òÈåÑË°®
CREATE TABLE conversations (
    conversation_id TEXT PRIMARY KEY,
    channel_id TEXT NOT NULL,
    guild_id TEXT NOT NULL,
    timestamp DATETIME NOT NULL,
    content TEXT NOT NULL,
    user_id TEXT NOT NULL,
    message_type TEXT DEFAULT 'user',
    metadata TEXT,
    relevance_score REAL DEFAULT 0.0,
    FOREIGN KEY (user_id) REFERENCES users(user_id)
);

-- Áî®Êà∂Âü∫Êú¨Ë≥áÊñôË°®
CREATE TABLE users (
    user_id TEXT PRIMARY KEY,
    discord_id TEXT UNIQUE NOT NULL,
    primary_nickname TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    last_active DATETIME DEFAULT CURRENT_TIMESTAMP,
    preferences TEXT, -- JSON Ê†ºÂºè
    activity_patterns TEXT -- JSON Ê†ºÂºè
);

-- Áî®Êà∂Ë©≥Á¥∞Ê™îÊ°àË°®
CREATE TABLE user_profiles (
    profile_id TEXT PRIMARY KEY,
    user_id TEXT NOT NULL,
    profile_data TEXT, -- JSON Ê†ºÂºèÁöÑÂÆåÊï¥Áî®Êà∂Ê™îÊ°à
    interaction_history TEXT, -- JSON Ê†ºÂºèÁöÑ‰∫íÂãïÊ≠∑Âè≤
    schedule_preferences TEXT, -- JSON Ê†ºÂºèÁöÑË°åÁ®ãÂÅèÂ•Ω
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(user_id)
);

-- Áî®Êà∂Êö±Á®±Ë°® (ÊîØÊè¥Ê®°Á≥äÊêúÂ∞ã)
CREATE TABLE user_nicknames (
    nickname_id TEXT PRIMARY KEY,
    user_id TEXT NOT NULL,
    nickname TEXT NOT NULL,
    confidence_score REAL DEFAULT 1.0,
    first_used DATETIME DEFAULT CURRENT_TIMESTAMP,
    last_used DATETIME DEFAULT CURRENT_TIMESTAMP,
    is_primary BOOLEAN DEFAULT FALSE,
    FOREIGN KEY (user_id) REFERENCES users(user_id)
);

-- Ë°åÁ®ãË°®
CREATE TABLE schedules (
    schedule_id TEXT PRIMARY KEY,
    user_id TEXT NOT NULL,
    title TEXT NOT NULL,
    start_time DATETIME NOT NULL,
    end_time DATETIME,
    description TEXT,
    schedule_data TEXT, -- JSON Ê†ºÂºèÁöÑË©≥Á¥∞Ë°åÁ®ãË≥áÊñô
    is_recurring BOOLEAN DEFAULT FALSE,
    recurrence_pattern TEXT,
    FOREIGN KEY (user_id) REFERENCES users(user_id)
);

-- ÊèêÈÜíË°®
CREATE TABLE reminders (
    reminder_id TEXT PRIMARY KEY,
    user_id TEXT NOT NULL,
    channel_id TEXT NOT NULL,
    message TEXT NOT NULL,
    remind_time DATETIME NOT NULL,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    status TEXT DEFAULT 'active', -- active, completed, cancelled
    metadata TEXT, -- JSON Ê†ºÂºèÁöÑÈ°çÂ§ñË≥áË®ä
    FOREIGN KEY (user_id) REFERENCES users(user_id)
);

-- Â∑•ÂÖ∑ÂõûÊáâÂø´ÂèñË°®
CREATE TABLE tool_responses (
    response_id TEXT PRIMARY KEY,
    tool_name TEXT NOT NULL,
    input_parameters TEXT, -- JSON Ê†ºÂºè
    output_data TEXT,
    execution_time REAL,
    timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
    conversation_id TEXT,
    relevance_score REAL DEFAULT 0.0,
    FOREIGN KEY (conversation_id) REFERENCES conversations(conversation_id)
);

-- Ë®òÊÜ∂Á¥¢ÂºïË°®
CREATE TABLE memory_index (
    memory_id TEXT PRIMARY KEY,
    conversation_id TEXT NOT NULL,
    channel_id TEXT NOT NULL,
    content TEXT NOT NULL,
    entities TEXT, -- JSON Ê†ºÂºèÁöÑÂØ¶È´îÊ∏ÖÂñÆ
    summary TEXT,
    timestamp DATETIME NOT NULL,
    importance_score REAL DEFAULT 0.0,
    FOREIGN KEY (conversation_id) REFERENCES conversations(conversation_id)
);

-- Áü•Ë≠òÂúñË≠úÂØ¶È´îË°®
CREATE TABLE knowledge_graph (
    entity_id TEXT PRIMARY KEY,
    entity_name TEXT NOT NULL,
    entity_type TEXT NOT NULL,
    properties TEXT, -- JSON Ê†ºÂºè
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- ÂØ¶È´îÈóú‰øÇË°®
CREATE TABLE entity_relationships (
    relationship_id TEXT PRIMARY KEY,
    entity1_id TEXT NOT NULL,
    entity2_id TEXT NOT NULL,
    relationship_type TEXT NOT NULL,
    confidence_score REAL DEFAULT 1.0,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (entity1_id) REFERENCES knowledge_graph(entity_id),
    FOREIGN KEY (entity2_id) REFERENCES knowledge_graph(entity_id)
);

-- Á¥¢ÂºïË®≠Ë®à
CREATE INDEX idx_conversations_channel_timestamp ON conversations(channel_id, timestamp);
CREATE INDEX idx_conversations_user_timestamp ON conversations(user_id, timestamp);
CREATE INDEX idx_user_nicknames_nickname ON user_nicknames(nickname);
CREATE INDEX idx_user_nicknames_user_id ON user_nicknames(user_id);
CREATE INDEX idx_schedules_user_time ON schedules(user_id, start_time);
CREATE INDEX idx_reminders_user_time ON reminders(user_id, remind_time);
CREATE INDEX idx_tool_responses_timestamp ON tool_responses(timestamp);
CREATE INDEX idx_memory_index_channel_importance ON memory_index(channel_id, importance_score);
```

## üß† Ê†∏ÂøÉÁ≥ªÁµ±Ë®≠Ë®à

### 1. Â§ö‰∫∫Â∞çË©±ÂàÜÊûêÂºïÊìé

```mermaid
classDiagram
    class MultiPersonConversationAnalyzer {
        +db_manager: SQLiteManager
        +participant_tracker: ParticipantTracker
        +relationship_analyzer: RelationshipAnalyzer
        +conversation_flow_detector: ConversationFlowDetector
        
        +analyze_conversation_context(messages: List[Message]) ConversationContext
        +identify_active_participants(channel_id: str) List[Participant]
        +detect_conversation_topics(conversation_id: str) List[Topic]
        +merge_participant_intents(intents: List[Intent]) MergedIntent
    }
    
    class SQLiteManager {
        +connection: sqlite3.Connection
        +conversation_dao: ConversationDAO
        +user_dao: UserDAO
        +memory_dao: MemoryDAO
        
        +store_conversation(message: Message) string
        +get_conversation_window(channel_id: str, limit: int) List[Message]
        +search_users_by_nickname(nickname: str) List[User]
        +get_user_profile(user_id: str) UserProfile
    }
    
    class ParticipantTracker {
        +active_users: Dict[str, UserInfo]
        +conversation_roles: Dict[str, Role]
        
        +track_user_activity(user_id: str, message: Message)
        +get_user_role_in_conversation(user_id: str) Role
        +analyze_user_interaction_style(user_id: str) InteractionStyle
        +load_user_from_db(user_id: str) User
    }
```

### 2. Êô∫ÊÖßË≥áË®ä‰æÜÊ∫êÈÅ∏ÊìáÂô®

```mermaid
classDiagram
    class InformationSourceSelector {
        +db_manager: SQLiteManager
        +context_analyzer: ContextAnalyzer
        +relevance_scorer: RelevanceScorer
        
        +select_information_sources(context: ConversationContext) List[InformationSource]
        +get_current_conversation(channel_id: str) List[Message]
        +get_user_information(user_ids: List[str]) List[UserProfile]
        +get_tool_responses(context: Context) List[ToolResponse]
        +get_long_term_memories(query: str, channel_id: str) List[Memory]
    }
    
    class SQLiteUserDAO {
        +find_user_by_nickname(nickname: str) Optional[User]
        +find_user_by_discord_id(discord_id: str) Optional[User]
        +get_user_profile(user_id: str) Optional[UserProfile]
        +update_user_activity(user_id: str, timestamp: datetime)
        +search_users_fuzzy(query: str) List[UserMatch]
    }
    
    class SQLiteMemoryDAO {
        +store_memory(conversation_id: str, content: str, entities: List[str])
        +search_memories(query: str, channel_id: str) List[Memory]
        +get_conversation_summary(conversation_id: str) Summary
        +update_memory_importance(memory_id: str, score: float)
    }
```

## üìä ÂõõÂ§ßË≥áË®ä‰æÜÊ∫êÁ≥ªÁµ± (SQLite ÂØ¶Áèæ)

### 1. Áï∂ÂâçÂ∞çË©±Ë®òÈåÑÁ≥ªÁµ± (ÂøÖÈ†à)

```python
class CurrentConversationRecord:
    """Áï∂ÂâçÂ∞çË©±Ë®òÈåÑÁ≥ªÁµ± - SQLite ÂØ¶Áèæ"""
    
    def __init__(self, db_manager: SQLiteManager):
        self.db = db_manager
    
    def get_conversation_window(self, channel_id: str, size: int = 10) -> List[Message]:
        """ÂèñÂæóÂ∞çË©±Á™óÂè£"""
        query = """
        SELECT conversation_id, content, user_id, timestamp, message_type, metadata
        FROM conversations 
        WHERE channel_id = ? 
        ORDER BY timestamp DESC 
        LIMIT ?
        """
        return self.db.execute_query(query, (channel_id, size))
    
    def store_message(self, message: discord.Message) -> str:
        """Â≠òÂÑ≤Ë®äÊÅØÂà∞ SQLite"""
        conversation_id = str(uuid.uuid4())
        query = """
        INSERT INTO conversations 
        (conversation_id, channel_id, guild_id, timestamp, content, user_id, message_type, metadata)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        """
        self.db.execute_query(query, (
            conversation_id,
            str(message.channel.id),
            str(message.guild.id),
            message.created_at,
            message.content,
            str(message.author.id),
            'user' if not message.author.bot else 'bot',
            json.dumps({"attachments": len(message.attachments)})
        ))
        return conversation_id
```

### 2. ÂèÉËàáËÄÖË≥áË®äÁ≥ªÁµ± (SQLite ÂØ¶Áèæ)

```python
class UserInformationSystem:
    """ÂèÉËàáËÄÖË≥áË®äÁ≥ªÁµ± - SQLite ÂØ¶Áèæ"""
    
    def __init__(self, db_manager: SQLiteManager):
        self.db = db_manager
    
    def get_user_by_nickname(self, nickname: str) -> Optional[UserProfile]:
        """ÈÄèÈÅéÊö±Á®±ÊêúÂ∞ãÁî®Êà∂ (Ê®°Á≥äÂåπÈÖç)"""
        query = """
        SELECT u.user_id, u.discord_id, u.primary_nickname, up.profile_data
        FROM users u
        JOIN user_nicknames un ON u.user_id = un.user_id
        LEFT JOIN user_profiles up ON u.user_id = up.user_id
        WHERE un.nickname LIKE ?
        ORDER BY un.confidence_score DESC, un.last_used DESC
        LIMIT 1
        """
        result = self.db.execute_query(query, (f"%{nickname}%",))
        return self._parse_user_profile(result[0]) if result else None
    
    def get_user_by_discord_id(self, discord_id: str) -> Optional[UserProfile]:
        """ÈÄèÈÅé Discord ID ÊêúÂ∞ãÁî®Êà∂"""
        query = """
        SELECT u.user_id, u.discord_id, u.primary_nickname, up.profile_data
        FROM users u
        LEFT JOIN user_profiles up ON u.user_id = up.user_id
        WHERE u.discord_id = ?
        """
        result = self.db.execute_query(query, (discord_id,))
        return self._parse_user_profile(result[0]) if result else None
    
    def update_user_nickname(self, user_id: str, nickname: str):
        """Êõ¥Êñ∞Áî®Êà∂Êö±Á®±"""
        # Ê™¢Êü•Êö±Á®±ÊòØÂê¶Â∑≤Â≠òÂú®
        existing_query = """
        SELECT nickname_id FROM user_nicknames 
        WHERE user_id = ? AND nickname = ?
        """
        existing = self.db.execute_query(existing_query, (user_id, nickname))
        
        if existing:
            # Êõ¥Êñ∞ÊúÄÂæå‰ΩøÁî®ÊôÇÈñì
            update_query = """
            UPDATE user_nicknames 
            SET last_used = CURRENT_TIMESTAMP 
            WHERE nickname_id = ?
            """
            self.db.execute_query(update_query, (existing[0]['nickname_id'],))
        else:
            # Êñ∞Â¢ûÊö±Á®±
            insert_query = """
            INSERT INTO user_nicknames (nickname_id, user_id, nickname, confidence_score)
            VALUES (?, ?, ?, ?)
            """
            self.db.execute_query(insert_query, (
                str(uuid.uuid4()), user_id, nickname, 1.0
            ))
```

### 3. Â∑•ÂÖ∑ÂõûÊáâË≥áË®äÁ≥ªÁµ± (SQLite ÂØ¶Áèæ)

```python
class ToolResponseCache:
    """Â∑•ÂÖ∑ÂõûÊáâÂø´ÂèñÁ≥ªÁµ± - SQLite ÂØ¶Áèæ"""
    
    def __init__(self, db_manager: SQLiteManager):
        self.db = db_manager
    
    def cache_tool_response(self, tool_name: str, input_params: dict, 
                          output_data: Any, execution_time: float,
                          conversation_id: str = None):
        """Âø´ÂèñÂ∑•ÂÖ∑ÂõûÊáâÂà∞ SQLite"""
        query = """
        INSERT INTO tool_responses 
        (response_id, tool_name, input_parameters, output_data, execution_time, conversation_id)
        VALUES (?, ?, ?, ?, ?, ?)
        """
        self.db.execute_query(query, (
            str(uuid.uuid4()),
            tool_name,
            json.dumps(input_params),
            str(output_data),
            execution_time,
            conversation_id
        ))
    
    def get_relevant_tool_responses(self, context: Context, limit: int = 5) -> List[ToolResponse]:
        """ÂèñÂæóÁõ∏ÈóúÁöÑÂ∑•ÂÖ∑ÂõûÊáâ"""
        query = """
        SELECT tool_name, input_parameters, output_data, execution_time, timestamp
        FROM tool_responses 
        WHERE tool_name IN ({})
        ORDER BY timestamp DESC, relevance_score DESC
        LIMIT ?
        """.format(','.join(['?' for _ in context.likely_tools]))
        
        params = list(context.likely_tools) + [limit]
        return self.db.execute_query(query, params)
```

### 4. Èï∑‰πÖË®òÊÜ∂Á≥ªÁµ± (SQLite + FAISS ÂØ¶Áèæ)

```python
class EnhancedLongTermMemory:
    """Èï∑‰πÖË®òÊÜ∂Á≥ªÁµ± - SQLite + FAISS ÂØ¶Áèæ"""
    
    def __init__(self, db_manager: SQLiteManager, vector_manager: VectorManager):
        self.db = db_manager
        self.vector_manager = vector_manager
    
    def store_conversation_memory(self, conversation_id: str, 
                                content: str, entities: List[str]):
        """Â≠òÂÑ≤Â∞çË©±Ë®òÊÜ∂"""
        # ÁîüÊàêÊëòË¶Å
        summary = self._generate_summary(content)
        
        # Ë®àÁÆóÈáçË¶ÅÊÄßÂàÜÊï∏
        importance_score = self._calculate_importance(content, entities)
        
        # Â≠òÂÑ≤Âà∞ SQLite
        query = """
        INSERT INTO memory_index 
        (memory_id, conversation_id, channel_id, content, entities, summary, timestamp, importance_score)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        """
        memory_id = str(uuid.uuid4())
        self.db.execute_query(query, (
            memory_id,
            conversation_id,
            self._get_channel_id_from_conversation(conversation_id),
            content,
            json.dumps(entities),
            summary,
            datetime.now(),
            importance_score
        ))
        
        # Â≠òÂÑ≤ÂêëÈáèÂà∞ FAISS
        vector = self.vector_manager.generate_embedding(content)
        self.vector_manager.add_vector(memory_id, vector)
    
    def search_relevant_memories(self, query: str, channel_id: str, 
                               limit: int = 5) -> List[Memory]:
        """ÊêúÂ∞ãÁõ∏ÈóúË®òÊÜ∂ (Ê∑∑ÂêàÊêúÂ∞ã)"""
        # ÂêëÈáèÊêúÂ∞ã
        query_vector = self.vector_manager.generate_embedding(query)
        vector_results = self.vector_manager.search_similar(query_vector, limit * 2)
        
        # SQLite ÈóúÈçµÂ≠óÊêúÂ∞ã
        sql_query = """
        SELECT memory_id, content, summary, importance_score, timestamp
        FROM memory_index
        WHERE channel_id = ? AND (content LIKE ? OR summary LIKE ?)
        ORDER BY importance_score DESC, timestamp DESC
        LIMIT ?
        """
        keyword_results = self.db.execute_query(sql_query, (
            channel_id, f"%{query}%", f"%{query}%", limit
        ))
        
        # Âêà‰ΩµÁµêÊûú
        return self._merge_search_results(vector_results, keyword_results, limit)
```

## üöÄ Â¢ûÂº∑Áâà ActionHandler Êï¥Âêà

### Áæ§ÁµÑÊÑüÁü•ÁöÑ ActionHandler (SQLite ÂØ¶Áèæ)

```python
class GroupAwareActionHandler:
    """Áæ§ÁµÑÊÑüÁü•ÁöÑ ActionHandler - SQLite ÂØ¶Áèæ"""
    
    def __init__(self, bot, db_manager: SQLiteManager):
        self.bot = bot
        self.db = db_manager
        self.conversation_analyzer = MultiPersonConversationAnalyzer(db_manager)
        self.information_selector = InformationSourceSelector(db_manager)
        self.user_system = UserInformationSystem(db_manager)
        self.tool_cache = ToolResponseCache(db_manager)
        self.memory_system = EnhancedLongTermMemory(db_manager, vector_manager)
    
    async def choose_act_with_context(self, prompt: str, message: discord.Message,
                                    message_to_edit: discord.Message) -> Callable:
        """Âü∫ÊñºÂ§öÂ±§Á¥öË≥áË®äÈÅ∏ÊìáÂãï‰Ωú"""
        
        # 1. ÂàÜÊûêÂ§ö‰∫∫Â∞çË©±ËÑàÁµ°
        conversation_context = self.conversation_analyzer.analyze_conversation_context(
            self._get_recent_messages(message.channel.id)
        )
        
        # 2. ÈÅ∏ÊìáË≥áË®ä‰æÜÊ∫ê
        information_needs = self.information_selector.determine_information_needs(
            conversation_context
        )
        
        # 3. Êï¥ÂêàË≥áË®ä‰æÜÊ∫ê
        integrated_context = await self._integrate_information_sources(
            conversation_context, information_needs, message
        )
        
        # 4. ÁîüÊàêÂãï‰ΩúÂàóË°®
        action_list = await self._generate_actions_with_context(
            prompt, integrated_context
        )
        
        # 5. Âü∑Ë°åÂãï‰Ωú
        return await self._execute_actions_with_context(
            action_list, message, message_to_edit, integrated_context
        )
    
    async def _integrate_information_sources(self, conversation_context: ConversationContext,
                                           information_needs: InformationNeeds,
                                           message: discord.Message) -> IntegratedContext:
        """Êï¥ÂêàÂõõÂ§ßË≥áË®ä‰æÜÊ∫ê"""
        
        context = IntegratedContext()
        
        # ÂøÖÈ†àÔºöÁï∂ÂâçÂ∞çË©±Ë®òÈåÑ
        context.current_conversation = self.db.get_conversation_window(
            str(message.channel.id), 10
        )
        
        # Ê¢ù‰ª∂ÔºöÂèÉËàáËÄÖË≥áË®ä
        if information_needs.requires_user_info:
            participants = conversation_context.participants
            context.user_information = {}
            for participant in participants:
                user_profile = self.user_system.get_user_by_discord_id(participant.discord_id)
                if user_profile:
                    context.user_information[participant.discord_id] = user_profile
        
        # Ê¢ù‰ª∂ÔºöÂ∑•ÂÖ∑ÂõûÊáâ
        if information_needs.requires_tool_responses:
            context.tool_responses = self.tool_cache.get_relevant_tool_responses(
                conversation_context
            )
        
        # Ê¢ù‰ª∂ÔºöÈï∑‰πÖË®òÊÜ∂
        if information_needs.requires_long_term_memory:
            context.historical_memories = self.memory_system.search_relevant_memories(
                conversation_context.main_topic, str(message.channel.id)
            )
        
        return context
```

## üìà ÂØ¶ÊñΩË∑ØÁ∑öÂúñ

### ÈöéÊÆµ‰∏ÄÔºöSQLite Ë≥áÊñôÂ∫´Âª∫Ë®≠ (3 ÈÄ±)

#### ÈÄ± 1ÔºöË≥áÊñôÂ∫´Êû∂ÊßãË®≠Ë®à
- **SQLite Ë≥áÊñôÂ∫´Ë®≠Ë®à**
  - Ë®≠Ë®àÂÆåÊï¥ÁöÑË≥áÊñôË°®ÁµêÊßã
  - Âª∫Á´ãÁ¥¢ÂºïÂíåÂ§ñÈçµÁ¥ÑÊùü
  - ÂØ¶ÁèæË≥áÊñôÂ∫´ÂàùÂßãÂåñËÖ≥Êú¨

- **Ë≥áÊñôÂ≠òÂèñÂ±§ (DAO)**
  - ÂØ¶Áèæ SQLiteManager Âü∫Á§éÈ°ûÂà•
  - Âª∫Á´ãÂêÑË≥áÊñôË°®ÁöÑ DAO È°ûÂà•
  - Ë®≠Ë®àÁµ±‰∏ÄÁöÑÊü•Ë©¢‰ªãÈù¢

#### ÈÄ± 2ÔºöMongoDB Âà∞ SQLite ÈÅ∑Áßª
- **Ë≥áÊñôÈÅ∑ÁßªÂ∑•ÂÖ∑**
  - ÂàÜÊûêÁèæÊúâ MongoDB Ë≥áÊñôÁµêÊßã
  - ÂØ¶ÁèæË≥áÊñôËΩâÊèõÂíåÈÅ∑ÁßªËÖ≥Êú¨
  - Âª∫Á´ãË≥áÊñôÂÆåÊï¥ÊÄßÈ©óË≠â

- **Á≥ªÁµ±ÈáçÊßã**
  - Êõ¥Êñ∞ UserDataCog ‰ΩøÁî® SQLite
  - ÈáçÊßã ScheduleManager Ë≥áÊñôÂ≠òÂèñ
  - Êõ¥Êñ∞ ReminderCog Â≠òÂÑ≤ÈÇèËºØ

#### ÈÄ± 3ÔºöÂ§ö‰∫∫Â∞çË©±ÂàÜÊûêÂºïÊìé
- **Â∞çË©±ÂèÉËàáËÄÖËøΩËπ§**
  - ÂØ¶ÁèæÂèÉËàáËÄÖË≠òÂà•ÂíåËøΩËπ§
  - Âª∫Á´ãÂ∞çË©±ËÑàÁµ°ÂàÜÊûê
  - Ë®≠Ë®àÁæ§ÁµÑÂãïÊÖãÊ™¢Ê∏¨

### ÈöéÊÆµ‰∫åÔºöÊô∫ÊÖßË≥áË®äÊï¥Âêà (4 ÈÄ±)

#### ÈÄ± 4-5ÔºöÂõõÂ§ßË≥áË®ä‰æÜÊ∫êÁ≥ªÁµ±
- **Áï∂ÂâçÂ∞çË©±Ë®òÈåÑÁ≥ªÁµ±**
  - ÂØ¶ÁèæÂ∞çË©±Á™óÂè£ÁÆ°ÁêÜ
  - Âª∫Á´ãÂç≥ÊôÇÂ∞çË©±ËøΩËπ§
  - Ë®≠Ë®àÂ∞çË©±ÂÖÉË≥áÊñôÂ≠òÂÑ≤

- **ÂèÉËàáËÄÖË≥áË®äÁ≥ªÁµ±**
  - ÂØ¶ÁèæÊö±Á®±Ê®°Á≥äÊêúÂ∞ã
  - Âª∫Á´ãÁî®Êà∂Ê™îÊ°àÁÆ°ÁêÜ
  - Ë®≠Ë®àÁî®Êà∂Ê¥ªÂãïËøΩËπ§

#### ÈÄ± 6-7ÔºöÂ∑•ÂÖ∑ËàáË®òÊÜ∂Á≥ªÁµ±
- **Â∑•ÂÖ∑ÂõûÊáâÂø´ÂèñÁ≥ªÁµ±**
  - ÂØ¶ÁèæÂ∑•ÂÖ∑ÂõûÊáâÂ≠òÂÑ≤
  - Âª∫Á´ãÊïàËÉΩËøΩËπ§Ê©üÂà∂
  - Ë®≠Ë®àÁõ∏ÈóúÊÄßË©ïÂàÜ

- **Èï∑‰πÖË®òÊÜ∂Á≥ªÁµ±Êï¥Âêà**
  - Êï¥ÂêàÁèæÊúâ FAISS ÂêëÈáèÁ≥ªÁµ±
  - ÂØ¶Áèæ SQLite + FAISS Ê∑∑ÂêàÊêúÂ∞ã
  - Âª∫Á´ãÁü•Ë≠òÂúñË≠úÂ≠òÂÑ≤

### ÈöéÊÆµ‰∏âÔºöÂ¢ûÂº∑Áâà ActionHandler (3 ÈÄ±)

#### ÈÄ± 8-9ÔºöÁæ§ÁµÑÊÑüÁü• ActionHandler
- **Êô∫ÊÖßË≥áË®äÈÅ∏ÊìáÂô®**
  - ÂØ¶Áèæ‰∏ä‰∏ãÊñáÊÑüÁü•ÁöÑË≥áË®ä‰æÜÊ∫êÈÅ∏Êìá
  - Âª∫Á´ãÂãïÊÖãÊ¨äÈáçË™øÊï¥Ê©üÂà∂
  - Ë®≠Ë®àË≥áË®äÊï¥ÂêàÁ≠ñÁï•

- **Â§ö‰∫∫Â∞çË©±ÁêÜËß£**
  - ÂØ¶ÁèæÁæ§ÁµÑÊÑèÂúñÂàÜÊûê
  - Âª∫Á´ãÂèÉËàáËÄÖÈóú‰øÇÁêÜËß£
  - Ë®≠Ë®àÂ∞çË©±ÊµÅÁ®ãËøΩËπ§

#### ÈÄ± 10ÔºöÁ≥ªÁµ±Êï¥ÂêàËàáÊ∏¨Ë©¶
- **Á´ØÂà∞Á´ØÊï¥Âêà**
  - ÂÆåÊï¥Á≥ªÁµ±ÂäüËÉΩÊ∏¨Ë©¶
  - Â§ö‰∫∫Â∞çË©±Â†¥ÊôØÈ©óË≠â
  - SQLite ÊïàËÉΩÊúÄ‰Ω≥Âåñ

- **ÈÉ®ÁΩ≤ËàáÊúÄ‰Ω≥Âåñ**
  - Ë≥áÊñôÂ∫´ÊïàËÉΩË™øÂÑ™
  - Ë®òÊÜ∂È´î‰ΩøÁî®ÊúÄ‰Ω≥Âåñ
  - Âª∫Á´ãÁõ£ÊéßÂíåÊó•Ë™åÁ≥ªÁµ±

## üéñÔ∏è È†êÊúüÊïàÁõä

### ÊäÄË°ìÊû∂ÊßãÂÑ™Âã¢
- **Áµ±‰∏Ä SQLite Â≠òÂÑ≤**ÔºöÁ∞°ÂåñÈÉ®ÁΩ≤ÔºåÁßªÈô§Â§ñÈÉ®Ë≥áÊñôÂ∫´‰æùË≥¥
- **Êô∫ÊÖßË≥áË®äÊï¥Âêà**ÔºöÂãïÊÖãÈÅ∏ÊìáÂõõÂ§ßË≥áË®ä‰æÜÊ∫êÔºåÊèêÂçáÂõûÊáâÂìÅË≥™
- **Áæ§ÁµÑÊÑüÁü•ËÉΩÂäõ**ÔºöÁêÜËß£Â§ö‰∫∫‰∫íÂãïÂãïÊÖãÔºåÊèê‰æõÈÅ©ÂàáÂèÉËàá
- **È´òÊïàËÉΩÊêúÂ∞ã**ÔºöSQLite + FAISS Ê∑∑ÂêàÊêúÂ∞ãÔºåÂπ≥Ë°°ÊïàËÉΩËàáÁ≤æÁ¢∫Â∫¶

### ÂäüËÉΩÊèêÂçáÊåáÊ®ô
- **Â§ö‰∫∫Â∞çË©±ÁêÜËß£Ê∫ñÁ¢∫Áéá**Ôºö85%+ ÁöÑÂ∞çË©±ËÑàÁµ°Ê≠£Á¢∫Ë≠òÂà•
- **Êö±Á®±ÊêúÂ∞ãÊàêÂäüÁéá**Ôºö90%+ ÁöÑÊ®°Á≥äÊö±Á®±ÊêúÂ∞ãÊàêÂäüÂåπÈÖç
- **Ë≥áË®ä‰æÜÊ∫êÈÅ∏ÊìáÁ≤æÊ∫ñÂ∫¶**Ôºö90%+ ÁöÑÊÉÖÊ≥Å‰∏ãÈÅ∏ÊìáÊ≠£Á¢∫ÁöÑË≥áË®ä‰æÜÊ∫êÁµÑÂêà
- **Áæ§ÁµÑ‰∫íÂãïËá™ÁÑ∂Â∫¶**ÔºöÁî®Êà∂ÊÑüÂèóÊ©üÂô®‰∫∫Â¶ÇÁæ§ÁµÑÊàêÂì°Ëà¨Ëá™ÁÑ∂ÂèÉËàá

### ÈÉ®ÁΩ≤ËàáÁ∂≠Ë≠∑ÂÑ™Âã¢
- **ÂñÆ‰∏ÄË≥áÊñôÂ∫´Ê™îÊ°à**ÔºöSQLite Ë≥áÊñôÂ∫´ÊòìÊñºÂÇô‰ªΩÂíåÈÅ∑Áßª
- **Èõ∂Â§ñÈÉ®‰æùË≥¥**ÔºöÁßªÈô§ MongoDBÔºåÁ∞°ÂåñÈÉ®ÁΩ≤Áí∞Â¢É
- **È´òÊïàÊü•Ë©¢**ÔºöÊúÄ‰Ω≥ÂåñÁöÑÁ¥¢ÂºïË®≠Ë®àÔºåÊèêÂçáÊü•Ë©¢ÊïàËÉΩ
- **Ë≥áÊñô‰∏ÄËá¥ÊÄß**ÔºöACID Â±¨ÊÄß‰øùË≠âË≥áÊñôÂÆåÊï¥ÊÄß

---

ÈÄôÂÄãÈáçÊñ∞Ë®≠Ë®àÁöÑÊû∂ÊßãÂÆåÂÖ®‰ΩøÁî® SQLite ‰ΩúÁÇ∫Áµ±‰∏ÄÁöÑË≥áÊñôÂ≠òÂÑ≤ÊñπÊ°àÔºåÊòØÂê¶Á¨¶ÂêàÊÇ®ÁöÑÊúüÊúõÔºüÊàëÁâπÂà•ËëóÈáçÊñºÔºö
1. ÂÆåÂÖ®ÁßªÈô§ MongoDBÔºåÁµ±‰∏Ä‰ΩøÁî® SQLite
2. Ë®≠Ë®àÂÆåÊï¥ÁöÑË≥áÊñôË°®ÁµêÊßãÂíåÈóúËÅØ
3. ‰øùÊåÅÂõõÂ§ßË≥áË®ä‰æÜÊ∫êÁöÑÊô∫ÊÖßÊï¥ÂêàËÉΩÂäõ
4. Êèê‰æõË©≥Á¥∞ÁöÑÂØ¶ÊñΩË∑ØÁ∑öÂúñ

ÊÇ®Â∏åÊúõÊàëË™øÊï¥‰ªª‰ΩïÁâπÂÆöÈÉ®ÂàÜÂóéÔºü