# pylint: disable=unnecessary-import

"""
This module defines the interface for vector stores in the memory system.

It includes:
- MemoryFragment: A dataclass for representing a piece of memory.
- VectorStoreInterface: An abstract base class for vector store implementations.
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional


@dataclass
class MemoryFragment:
    """
    Represents a single fragment of episodic memory, ready for storage and retrieval.

    Fields:
    - id: Optional stable identifier for the fragment (string)
    - content: human-readable summary generated by an LLM
    - query_key: keyword-rich string used for vectorization
    - metadata: rich dict used for filtering and context
    - score: optional similarity score returned by search APIs

    metadata keys:
    - fragment_id: stable id for fragment (str)
    - source_message_ids: list of origin message ids
    - jump_url: link to the original message
    - author_id, channel_id, guild_id: identifiers
    - timestamp: numeric UNIX timestamp in seconds (float or int). Example: 1699721600.123
    - reactions_json: serialized reactions
    """
    id: Optional[str] = None
    content: str = ""
    query_key: str = ""
    metadata: Dict[str, Any] = field(default_factory=dict)
    score: Optional[float] = None

    def __post_init__(self):
        """
        Log missing metadata keys rather than raising, to be permissive for stores that
        may not supply every field. Consumers that require strictness should validate
        separately.
        """
        required_keys = [
            'fragment_id',
            'source_message_ids',
            'jump_url',
            'author_id',
            'channel_id',
            'guild_id',
            'timestamp',
            'reactions_json'
        ]
        missing = [k for k in required_keys if k not in self.metadata]
        if missing:
            # Do not raise here to preserve compatibility with stores that omit fields.
            # Emit a warning to aid debugging.
            import logging
            logging.getLogger(__name__).warning("MemoryFragment metadata missing keys: %s", missing)


class VectorStoreInterface(ABC):
    """
    Abstract base class for vector store implementations.

    This class defines the standard interface for adding and searching memories
    in a vector store.
    """

    @abstractmethod
    async def add_memories(self, memories: List[MemoryFragment]) -> None:
        """
        Adds a list of memory fragments to the vector store.

        Args:
            memories: A list of MemoryFragment objects to be added.
        """
        raise NotImplementedError

    @abstractmethod
    async def search_memories_by_vector(
        self,
        query_text: str,
        limit: int = 8,
        user_id: Optional[str] = None,
        channel_id: Optional[str] = None,
        min_score: Optional[float] = None,
    ) -> List[MemoryFragment]:
        """
        Search memories using vector similarity.

        Args:
            query_text: The text to vectorize and search with.
            limit: Maximum number of results to return.
            user_id: Optional user id to restrict results.
            channel_id: Optional channel id to restrict results.
            min_score: Optional minimum similarity score to include.

        Returns:
            A list of MemoryFragment objects that match the vector query.
        """
        raise NotImplementedError

    @abstractmethod
    async def search_memories_by_keyword(
        self,
        query_text: str,
        user_id: Optional[str] = None,
        channel_id: Optional[str] = None,
        k: int = 5
    ) -> List[MemoryFragment]:
        """
        Search memories using keyword / full-text payload matching.

        This method should not vectorize the query_text. Implementations
        are expected to use the vector store's text-matching capabilities
        (for example Qdrant's MatchText + scroll/search APIs) and support
        filtering by user_id and channel_id.

        Args:
            query_text: Raw text to match against payload text fields.
            user_id: Optional user id to restrict results.
            channel_id: Optional channel id to restrict results.
            k: Number of results to return.

        Returns:
            A list of MemoryFragment objects that match the keyword query.
        """
        raise NotImplementedError

    @abstractmethod
    async def ensure_storage(self) -> None:
        """
        Ensure underlying storage exists and is ready (for example create collections
        and payload indexes). Implementations should be idempotent and safe to call
        multiple times.
        """
        raise NotImplementedError
    
    @abstractmethod
    async def search(
        self,
        vector_query: Optional[str] = None,
        keyword_query: Optional[str] = None,
        user_id: Optional[str] = None,
        channel_id: Optional[str] = None
    ) -> List[MemoryFragment]:
        """
        Performs a hybrid search using separate vector and keyword queries.

        At least one of `vector_query` or `keyword_query` must be provided.
        Implementations should handle the following cases:
        - Only `vector_query`: perform vector search.
        - Only `keyword_query`: perform keyword search.
        - Both provided: perform both searches and merge/deduplicate results.
        """
        raise NotImplementedError