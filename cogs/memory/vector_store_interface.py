# pylint: disable=unnecessary-import

"""
This module defines the interface for vector stores in the memory system.

It includes:
- MemoryFragment: A dataclass for representing a piece of memory.
- VectorStoreInterface: An abstract base class for vector store implementations.
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional


@dataclass
class MemoryFragment:
    """
    Represents a single fragment of episodic memory, ready for storage and retrieval.
    This structure separates the human-readable summary from the machine-searchable query key.
    """
    content: str  # The human-readable summary of the memory, generated by an LLM.
    query_key: str  # A keyword-rich string for vectorization, generated by an LLM.
    
    metadata: Dict[str, Any] = field(default_factory=dict)
    """
    A rich dictionary of metadata for filtering and context.
    Expected keys include:
    - fragment_id: str (UUID)
    - source_message_ids: List[str]
    - jump_url: str (URL to the primary source message)
    - author_id: str
    - channel_id: str
    - guild_id: str
    - timestamp: float (UTC timestamp)
    - reactions_json: str (JSON string of reaction data)
    """

    def __post_init__(self):
        """
        Validates that all required metadata keys are present.
        """
        required_keys = [
            'fragment_id',
            'source_message_ids',
            'jump_url',
            'author_id',
            'channel_id',
            'guild_id',
            'timestamp',
            'reactions_json'
        ]
        for key in required_keys:
            if key not in self.metadata:
                raise ValueError(f"Missing required metadata key: {key}")


class VectorStoreInterface(ABC):
    """
    Abstract base class for vector store implementations.

    This class defines the standard interface for adding and searching memories
    in a vector store.
    """

    @abstractmethod
    async def add_memories(self, memories: List[MemoryFragment]) -> None:
        """
        Adds a list of memory fragments to the vector store.

        Args:
            memories: A list of MemoryFragment objects to be added.
        """
        raise NotImplementedError

    @abstractmethod
    async def search_memories_by_vector(
        self,
        query_text: str,
        limit: int = 8,
        user_id: Optional[str] = None,
        channel_id: Optional[str] = None,
        min_score: Optional[float] = None,
    ) -> List[MemoryFragment]:
        """
        Search memories using vector similarity.

        Args:
            query_text: The text to vectorize and search with.
            limit: Maximum number of results to return.
            user_id: Optional user id to restrict results.
            channel_id: Optional channel id to restrict results.
            min_score: Optional minimum similarity score to include.

        Returns:
            A list of MemoryFragment objects that match the vector query.
        """
        raise NotImplementedError

    @abstractmethod
    async def search_memories_by_keyword(
        self,
        query_text: str,
        user_id: Optional[str] = None,
        channel_id: Optional[str] = None,
        k: int = 5
    ) -> List[MemoryFragment]:
        """
        Search memories using keyword / full-text payload matching.
    
        This method should not vectorize the query_text. Implementations
        are expected to use the vector store's text-matching capabilities
        (for example Qdrant's MatchText + scroll/search APIs) and support
        filtering by user_id and channel_id.
    
        Args:
            query_text: Raw text to match against payload text fields.
            user_id: Optional user id to restrict results.
            channel_id: Optional channel id to restrict results.
            k: Number of results to return.
    
        Returns:
            A list of MemoryFragment objects that match the keyword query.
        """
        raise NotImplementedError
    
    @abstractmethod
    async def search(
        self,
        vector_query: Optional[str] = None,
        keyword_query: Optional[str] = None,
        user_id: Optional[str] = None,
        channel_id: Optional[str] = None
    ) -> List[MemoryFragment]:
        """
        Performs a hybrid search using separate vector and keyword queries.

        At least one of `vector_query` or `keyword_query` must be provided.
        Implementations should handle the following cases:
        - Only `vector_query`: perform vector search.
        - Only `keyword_query`: perform keyword search.
        - Both provided: perform both searches and merge/deduplicate results.
        """
        raise NotImplementedError